// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ffmpeg/proto/config.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GPUOptions struct {
	// Fraction of the available GPU memory to allocate for each process.
	// 1 means to allocate all of the GPU memory, 0.5 means the process
	// allocates up to ~50% of the available GPU memory.
	//
	// GPU memory is pre-allocated unless the allow_growth option is enabled.
	//
	// If greater than 1.0, uses CUDA unified memory to potentially oversubscribe
	// the amount of memory available on the GPU device by using host memory as a
	// swap space. Accessing memory not available on the device will be
	// significantly slower as that would require memory transfer between the host
	// and the device. Options to reduce the memory requirement should be
	// considered before enabling this option as this may come with a negative
	// performance impact. Oversubscription using the unified memory requires
	// Pascal class or newer GPUs and it is currently only supported on the Linux
	// operating system. See
	// https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-requirements
	// for the detailed requirements.
	PerProcessGpuMemoryFraction float64 `protobuf:"fixed64,1,opt,name=per_process_gpu_memory_fraction,json=perProcessGpuMemoryFraction,proto3" json:"per_process_gpu_memory_fraction,omitempty"`
	// If true, the allocator does not pre-allocate the entire specified
	// GPU memory region, instead starting small and growing as needed.
	AllowGrowth bool `protobuf:"varint,4,opt,name=allow_growth,json=allowGrowth,proto3" json:"allow_growth,omitempty"`
	// The type of GPU allocation strategy to use.
	//
	// Allowed values:
	// "": The empty string (default) uses a system-chosen default
	//     which may change over time.
	//
	// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
	//        version of dlmalloc.
	AllocatorType string `protobuf:"bytes,2,opt,name=allocator_type,json=allocatorType,proto3" json:"allocator_type,omitempty"`
	// Delay deletion of up to this many bytes to reduce the number of
	// interactions with gpu driver code.  If 0, the system chooses
	// a reasonable default (several MBs).
	DeferredDeletionBytes int64 `protobuf:"varint,3,opt,name=deferred_deletion_bytes,json=deferredDeletionBytes,proto3" json:"deferred_deletion_bytes,omitempty"`
	// A comma-separated list of GPU ids that determines the 'visible'
	// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
	// can see 8 GPU devices in the process, and one wanted to map
	// visible GPU devices 5 and 3 as "/device:GPU:0", and "/device:GPU:1",
	// then one would specify this field as "5,3".  This field is similar in
	// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
	// it applies to the visible GPU devices in the process.
	//
	// NOTE:
	// 1. The GPU driver provides the process with the visible GPUs
	//    in an order which is not guaranteed to have any correlation to
	//    the *physical* GPU id in the machine.  This field is used for
	//    remapping "visible" to "virtual", which means this operates only
	//    after the process starts.  Users are required to use vendor
	//    specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
	//    physical to visible device mapping prior to invoking TensorFlow.
	// 2. In the code, the ids in this list are also called "platform GPU id"s,
	//    and the 'virtual' ids of GPU devices (i.e. the ids in the device
	//    name "/device:GPU:<id>") are also called "TF GPU id"s. Please
	//    refer to third_party/tensorflow/core/common_runtime/gpu/gpu_id.h
	//    for more information.
	VisibleDeviceList string `protobuf:"bytes,5,opt,name=visible_device_list,json=visibleDeviceList,proto3" json:"visible_device_list,omitempty"`
	// In the event polling loop sleep this many microseconds between
	// PollEvents calls, when the queue is not empty.  If value is not
	// set or set to 0, gets set to a non-zero default.
	PollingActiveDelayUsecs int32 `protobuf:"varint,6,opt,name=polling_active_delay_usecs,json=pollingActiveDelayUsecs,proto3" json:"polling_active_delay_usecs,omitempty"`
	// This field is deprecated and ignored.
	PollingInactiveDelayMsecs int32 `protobuf:"varint,7,opt,name=polling_inactive_delay_msecs,json=pollingInactiveDelayMsecs,proto3" json:"polling_inactive_delay_msecs,omitempty"`
	// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
	// enabling this option forces all CPU tensors to be allocated with Cuda
	// pinned memory. Normally, TensorFlow will infer which tensors should be
	// allocated as the pinned memory. But in case where the inference is
	// incomplete, this option can significantly speed up the cross-device memory
	// copy performance as long as it fits the memory.
	// Note that this option is not something that should be
	// enabled by default for unknown or very large models, since all Cuda pinned
	// memory is unpageable, having too much pinned memory might negatively impact
	// the overall host system performance.
	ForceGpuCompatible bool `protobuf:"varint,8,opt,name=force_gpu_compatible,json=forceGpuCompatible,proto3" json:"force_gpu_compatible,omitempty"`
	// Unused
	Experimental         *anypb.Any `protobuf:"bytes,9,opt,name=experimental,proto3" json:"experimental,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GPUOptions) Reset()         { *m = GPUOptions{} }
func (m *GPUOptions) String() string { return proto.CompactTextString(m) }
func (*GPUOptions) ProtoMessage()    {}
func (*GPUOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a70d16b1a420d28a, []int{0}
}

func (m *GPUOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GPUOptions.Unmarshal(m, b)
}
func (m *GPUOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GPUOptions.Marshal(b, m, deterministic)
}
func (m *GPUOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUOptions.Merge(m, src)
}
func (m *GPUOptions) XXX_Size() int {
	return xxx_messageInfo_GPUOptions.Size(m)
}
func (m *GPUOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GPUOptions proto.InternalMessageInfo

func (m *GPUOptions) GetPerProcessGpuMemoryFraction() float64 {
	if m != nil {
		return m.PerProcessGpuMemoryFraction
	}
	return 0
}

func (m *GPUOptions) GetAllowGrowth() bool {
	if m != nil {
		return m.AllowGrowth
	}
	return false
}

func (m *GPUOptions) GetAllocatorType() string {
	if m != nil {
		return m.AllocatorType
	}
	return ""
}

func (m *GPUOptions) GetDeferredDeletionBytes() int64 {
	if m != nil {
		return m.DeferredDeletionBytes
	}
	return 0
}

func (m *GPUOptions) GetVisibleDeviceList() string {
	if m != nil {
		return m.VisibleDeviceList
	}
	return ""
}

func (m *GPUOptions) GetPollingActiveDelayUsecs() int32 {
	if m != nil {
		return m.PollingActiveDelayUsecs
	}
	return 0
}

func (m *GPUOptions) GetPollingInactiveDelayMsecs() int32 {
	if m != nil {
		return m.PollingInactiveDelayMsecs
	}
	return 0
}

func (m *GPUOptions) GetForceGpuCompatible() bool {
	if m != nil {
		return m.ForceGpuCompatible
	}
	return false
}

func (m *GPUOptions) GetExperimental() *anypb.Any {
	if m != nil {
		return m.Experimental
	}
	return nil
}

// Session configuration parameters.
// The system picks appropriate values for fields that are not set.
type ConfigProto struct {
	// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
	// number of devices of that type to use.  If a particular device
	// type is not found in the map, the system picks an appropriate
	// number.
	DeviceCount map[string]int32 `protobuf:"bytes,1,rep,name=device_count,json=deviceCount,proto3" json:"device_count,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Options that apply to all GPUs.
	GpuOptions           *GPUOptions `protobuf:"bytes,6,opt,name=gpu_options,json=gpuOptions,proto3" json:"gpu_options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ConfigProto) Reset()         { *m = ConfigProto{} }
func (m *ConfigProto) String() string { return proto.CompactTextString(m) }
func (*ConfigProto) ProtoMessage()    {}
func (*ConfigProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_a70d16b1a420d28a, []int{1}
}

func (m *ConfigProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigProto.Unmarshal(m, b)
}
func (m *ConfigProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigProto.Marshal(b, m, deterministic)
}
func (m *ConfigProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigProto.Merge(m, src)
}
func (m *ConfigProto) XXX_Size() int {
	return xxx_messageInfo_ConfigProto.Size(m)
}
func (m *ConfigProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigProto.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigProto proto.InternalMessageInfo

func (m *ConfigProto) GetDeviceCount() map[string]int32 {
	if m != nil {
		return m.DeviceCount
	}
	return nil
}

func (m *ConfigProto) GetGpuOptions() *GPUOptions {
	if m != nil {
		return m.GpuOptions
	}
	return nil
}

func init() {
	proto.RegisterType((*GPUOptions)(nil), "proto.GPUOptions")
	proto.RegisterType((*ConfigProto)(nil), "proto.ConfigProto")
	proto.RegisterMapType((map[string]int32)(nil), "proto.ConfigProto.DeviceCountEntry")
}

func init() { proto.RegisterFile("ffmpeg/proto/config.proto", fileDescriptor_a70d16b1a420d28a) }

var fileDescriptor_a70d16b1a420d28a = []byte{
	// 489 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0x61, 0x6f, 0xd3, 0x3e,
	0x10, 0xc6, 0xe5, 0xf5, 0xdf, 0xfd, 0x57, 0xa7, 0xa0, 0xcd, 0x14, 0x2d, 0x2d, 0x48, 0x84, 0x21,
	0xa4, 0xbc, 0x4a, 0x51, 0x91, 0xd0, 0x04, 0x12, 0x68, 0xb4, 0xac, 0x42, 0x62, 0xa2, 0x8a, 0xd8,
	0x6b, 0x2b, 0x4d, 0x2e, 0xc1, 0xc2, 0x89, 0x2d, 0xc7, 0xe9, 0xc8, 0x47, 0xe4, 0xcb, 0xf0, 0x19,
	0x90, 0x2f, 0xe9, 0xc6, 0x78, 0x55, 0xdf, 0x3d, 0xbf, 0x7b, 0xea, 0x9c, 0x1f, 0x3a, 0xcd, 0xf3,
	0x52, 0x43, 0x31, 0xd7, 0x46, 0x59, 0x35, 0x4f, 0x55, 0x95, 0x8b, 0x22, 0xc2, 0x82, 0x0d, 0xf1,
	0x67, 0x36, 0x2d, 0x94, 0x2a, 0x24, 0x74, 0xc4, 0xb6, 0xc9, 0xe7, 0x49, 0xd5, 0x76, 0xc4, 0xd9,
	0xef, 0x01, 0xa5, 0xeb, 0xcd, 0xf5, 0x57, 0x6d, 0x85, 0xaa, 0x6a, 0xb6, 0xa2, 0xcf, 0x34, 0x18,
	0xae, 0x8d, 0x4a, 0xa1, 0xae, 0x79, 0xa1, 0x1b, 0x5e, 0x42, 0xa9, 0x4c, 0xcb, 0x73, 0x93, 0xa4,
	0x8e, 0xf1, 0x49, 0x40, 0x42, 0x12, 0x3f, 0xd1, 0x60, 0x36, 0x1d, 0xb5, 0xd6, 0xcd, 0x15, 0x32,
	0x97, 0x3d, 0xc2, 0x9e, 0xd3, 0x71, 0x22, 0xa5, 0xba, 0xe1, 0x85, 0x51, 0x37, 0xf6, 0xbb, 0xff,
	0x5f, 0x40, 0xc2, 0xa3, 0xd8, 0xc3, 0xde, 0x1a, 0x5b, 0xec, 0x25, 0x7d, 0xe8, 0xca, 0x34, 0xb1,
	0xca, 0x70, 0xdb, 0x6a, 0xf0, 0x0f, 0x02, 0x12, 0x8e, 0xe2, 0x07, 0xb7, 0xdd, 0x6f, 0xad, 0x06,
	0xf6, 0x86, 0x9e, 0x66, 0x90, 0x83, 0x31, 0x90, 0xf1, 0x0c, 0x24, 0x38, 0x7b, 0xbe, 0x6d, 0x2d,
	0xd4, 0xfe, 0x20, 0x20, 0xe1, 0x20, 0x7e, 0xbc, 0x97, 0x57, 0xbd, 0xfa, 0xd1, 0x89, 0x2c, 0xa2,
	0x8f, 0x76, 0xa2, 0x16, 0x5b, 0x09, 0x3c, 0x83, 0x9d, 0x48, 0x81, 0x4b, 0x51, 0x5b, 0x7f, 0x88,
	0xff, 0x71, 0xd2, 0x4b, 0x2b, 0x54, 0xbe, 0x88, 0xda, 0xb2, 0x77, 0x74, 0xa6, 0x95, 0x94, 0xa2,
	0x2a, 0xb8, 0xfb, 0x86, 0x9d, 0x1b, 0x93, 0x49, 0xcb, 0x9b, 0x1a, 0xd2, 0xda, 0x3f, 0x0c, 0x48,
	0x38, 0x8c, 0x4f, 0x7b, 0xe2, 0x02, 0x81, 0x95, 0xd3, 0xaf, 0x9d, 0xcc, 0x3e, 0xd0, 0xa7, 0xfb,
	0x61, 0x51, 0xdd, 0x1b, 0x2f, 0x71, 0xfc, 0x7f, 0x1c, 0x9f, 0xf6, 0xcc, 0xe7, 0x1e, 0x41, 0x83,
	0x2b, 0x34, 0x78, 0x45, 0x27, 0xb9, 0x32, 0x29, 0xe0, 0xbe, 0x53, 0x55, 0xea, 0xc4, 0xba, 0xfb,
	0xf9, 0x47, 0xb8, 0x37, 0x86, 0xda, 0x5a, 0x37, 0xcb, 0x5b, 0x85, 0x9d, 0xd3, 0x31, 0xfc, 0xd4,
	0x60, 0x44, 0x09, 0x95, 0x4d, 0xa4, 0x3f, 0x0a, 0x48, 0xe8, 0x2d, 0x26, 0x51, 0xf7, 0xd0, 0xd1,
	0xfe, 0xa1, 0xa3, 0x8b, 0xaa, 0x8d, 0xef, 0x91, 0x67, 0xbf, 0x08, 0xf5, 0x96, 0x98, 0x91, 0x0d,
	0x46, 0xe4, 0x92, 0x8e, 0xfb, 0x0d, 0xa5, 0xaa, 0xa9, 0xac, 0x4f, 0x82, 0x41, 0xe8, 0x2d, 0x5e,
	0x74, 0x16, 0xd1, 0x5f, 0x64, 0xd4, 0xad, 0x6b, 0xe9, 0xa8, 0x4f, 0x95, 0x35, 0x6d, 0xec, 0x65,
	0x77, 0x1d, 0xb6, 0xa0, 0x9e, 0xbb, 0xbd, 0xea, 0x82, 0x84, 0x2b, 0xf3, 0x16, 0x27, 0xbd, 0xcd,
	0x5d, 0xc2, 0x62, 0x5a, 0xe8, 0xa6, 0x3f, 0xcf, 0xde, 0xd3, 0xe3, 0x7f, 0x4d, 0xd9, 0x31, 0x1d,
	0xfc, 0x80, 0x16, 0x53, 0x36, 0x8a, 0xdd, 0x91, 0x4d, 0xe8, 0x70, 0x97, 0xc8, 0xa6, 0x4b, 0xc8,
	0x30, 0xee, 0x8a, 0xb7, 0x07, 0xe7, 0x64, 0x7b, 0x88, 0xee, 0xaf, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0xf7, 0x35, 0x97, 0xe6, 0x02, 0x03, 0x00, 0x00,
}
